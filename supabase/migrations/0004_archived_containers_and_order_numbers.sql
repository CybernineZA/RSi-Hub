-- RSi Hub migration 0004
-- Adds:
-- 1) public.orders.order_no identity column (auto-increment display number)
-- 2) public.archived_containers and public.archived_container_items (Option 2 archive strategy)
-- Note: Policies are created using DROP POLICY IF EXISTS + CREATE POLICY to avoid nested dollar-quoting.

-- 1) Orders: order_no identity column
alter table if exists public.orders
  add column if not exists order_no bigint generated by default as identity;

-- Backfill any existing rows that do not have an order_no yet
DO $do$
declare
  seq_name text;
begin
  select pg_get_serial_sequence('public.orders', 'order_no') into seq_name;
  if seq_name is not null then
    execute format('update public.orders set order_no = nextval(%L) where order_no is null', seq_name);
  end if;
exception when undefined_table then
  -- orders table does not exist in this environment
  null;
end
$do$;

create unique index if not exists orders_order_no_uniq on public.orders(order_no);

-- 2) Archived containers
create table if not exists public.archived_containers (
  id uuid primary key,
  war_id uuid not null references public.wars(id) on delete cascade,
  yard_id uuid references public.yards(id) on delete set null,
  label text not null,
  state public.container_state not null default 'delivered',
  max_slots int not null default 60,
  current_slots int not null default 0,
  assigned_shipment_id uuid references public.shipments(id) on delete set null,
  archived_at timestamptz not null default now(),
  created_by uuid references auth.users(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists archived_containers_war_id_idx on public.archived_containers(war_id);
create index if not exists archived_containers_assigned_shipment_idx on public.archived_containers(assigned_shipment_id);

create table if not exists public.archived_container_items (
  id uuid primary key,
  container_id uuid not null references public.archived_containers(id) on delete cascade,
  item_id uuid not null references public.items(id) on delete restrict,
  qty_required int not null default 0,
  qty_done int not null default 0,
  slot_count int not null default 1,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists archived_container_items_container_id_idx on public.archived_container_items(container_id);

-- RLS (read-only from client; writes happen server-side with service-role)
alter table public.archived_containers enable row level security;
alter table public.archived_container_items enable row level security;

-- Policies (Postgres does not support CREATE POLICY IF NOT EXISTS in many versions)
drop policy if exists archived_containers_select on public.archived_containers;
create policy archived_containers_select
  on public.archived_containers
  for select
  to authenticated
  using (public.rsi_can_access_war(war_id));

drop policy if exists archived_container_items_select on public.archived_container_items;
create policy archived_container_items_select
  on public.archived_container_items
  for select
  to authenticated
  using (
    exists (
      select 1
      from public.archived_containers c
      where c.id = archived_container_items.container_id
        and public.rsi_can_access_war(c.war_id)
    )
  );
